#include <lynxmotion_al5d_description/manager.h>

int Manager::numSpawned;

Manager::Manager(ros::NodeHandle& nh_)
{
    nh = nh_;
}

int Manager::brickIndex(std::string name)
{
    int index = -1, ind = 0;
    for (Brick* brick : bricks)
    {
        if (brick->getName() == name) 
        {
            index = ind;
            break;
        }
        ++ind;
    }
    return index;
}

bool Manager::spawnBrick(lynxmotion_al5d_description::SpawnBrick::Request &req,
                    lynxmotion_al5d_description::SpawnBrick::Response &res)
{
    std::string name;
    if (req.name == "")
    {
        name = "brick" + std::to_string(++numSpawned);
    }
    else
    {
        if (brickIndex(req.name) == -1)
        {
            name = req.name;
        }
        else
        {
            ROS_ERROR("SpawnBrick: Brick %s already exists.", req.name.c_str());
            return false;
        }
    }

    Brick* brick = new Brick (nh, req.color, name, req.pose.position.x, req.pose.position.y, req.pose.position.z, req.pose.orientation.roll, req.pose.orientation.pitch, req.pose.orientation.yaw);
    ros::service::waitForService("/gazebo/spawn_sdf_model");
    gazebo_msgs::SpawnModel srv;
    srv.request.model_name = name;
    srv.request.robot_namespace = ROBOT_NAMESPACE;
    std::string xml;
    nh.getParam(req.color + ROBOT_PARAM_SUFFIX, xml);
    srv.request.model_xml = xml;
    srv.request.initial_pose = brick->getPose(); 
    if (ros::service::call("/gazebo/spawn_sdf_model", srv))
    {
        bricks.push_back(brick);
        res.name = brick->getName();
    }
    else
    {
        --numSpawned;
        ROS_ERROR("Failed to call service spawn_brick.\n");
        return false;
    }
    return true;
}

bool Manager::killBrick(lynxmotion_al5d_description::KillBrick::Request &req,
                lynxmotion_al5d_description::KillBrick::Response &res)
{
    int index = brickIndex(req.name); 
    if (index == -1)
    {
        // Could not find the brick
        ROS_ERROR("KillBrick: Model %s doesn't exist.", req.name.c_str());
        return false;
    }
    // Implicit else
    ros::service::waitForService("/gazebo/delete_model");
    gazebo_msgs::DeleteModel srv;
    srv.request.model_name = req.name;

    if (ros::service::call("/gazebo/delete_model", srv))
    {
        res.result = srv.response.success;
        res.message = srv.response.status_message;
        // If the brick was the last one with the name generated by the program, update the count
        if (("brick" + std::to_string(numSpawned)) == bricks[index]->getName())
        {
            --numSpawned;
        }
        delete bricks[index];
        bricks.erase(bricks.begin() + index);
    }
    else
    {
        ROS_ERROR("Failed to call service kill_brick");
        return false;
    }
    return true;
}

bool Manager::clear(lynxmotion_al5d_description::Clear::Request &req,
            lynxmotion_al5d_description::Clear::Response &res)
{
    lynxmotion_al5d_description::KillBrick::Request b_req;
    lynxmotion_al5d_description::KillBrick::Response b_res;
    std::vector<std::string> names;
    for (Brick* brick : bricks)
    {
        names.push_back(brick->getName());
    }
    for (std::string name : names)
    {
        b_req.name = name;
        killBrick(b_req, b_res);
    }
    Manager::numSpawned = 0;
    return true;
}

bool Manager::reset(lynxmotion_al5d_description::Reset::Request &req,
            lynxmotion_al5d_description::Reset::Response &res)
{
    lynxmotion_al5d_description::Clear::Request b_req;
    lynxmotion_al5d_description::Clear::Response b_res;

    // Call the clear method
    clear(b_req, b_res);

    // Now send the robot back to the (0 0 0 0 0 0) position
    ros::Publisher pub = nh.advertise<std_msgs::Float64MultiArray>("/lynxmotion_al5d/joints_positions/command", 100);
    while (pub.getNumSubscribers() < 1)
    {
        // Wait until there is connection.
    }
    std_msgs::Float64MultiArray msg;
    std::vector<double> vals = {0.00, 1.5700, -1.5700, 0.00, 0.00, 0.00};
    msg.data.clear();
    msg.data.insert(msg.data.end(), vals.begin(), vals.end());
    pub.publish(msg);

    return true;
}
